#!/usr/bin/env python3
import argparse
from argparse import ArgumentParser
import re, yaml
from typing import Dict, List, Tuple, Optional

parser = ArgumentParser()
parser.add_argument("-q", "--quiet", action='store_true')
parser.add_argument("yml_file")
parser.add_argument("keys", nargs=argparse.REMAINDER)
args = parser.parse_args()

try:
    with open(args.yml_file) as f:
        entries = yaml.load(f, Loader=yaml.SafeLoader)
except FileNotFoundError:
    if args.quiet:
        exit(1)
    raise

def find_item(map: Dict, key_list: str) -> Tuple[List[str], Optional[str]]:
    """ For a dictionary of regular expressions,
    returns the leaf which recursively matches the passed in values
    :returns: (Matched groups throughout recursive tree navigation, final value)
    """
    for k, v in map.items():
        match = re.fullmatch(k, key_list[0])
        if not match:
            continue
        if len(key_list) > 1:
            groups, value = find_item(v, key_list[1:])
            if value is not None:
                return list(match.groups()) + groups, value
        else:
            return list(match.groups()), v
    return [], None

groups, value = find_item(entries, args.keys)
if value is not None:
    # No matched groups, so job is simple
    if not any(groups):
        print(value)
        exit(0)

    # Otherwise, you may have to substitute matched groups
    # This smells. Create a regular expression which is just the matched groups
    # This will almost certainly break eventually
    mock_re = '.*'+ '.*?'.join([f'({g})' for g in groups if g]) + '.*'
    print(re.sub(mock_re, value, ''.join(args.keys)))
